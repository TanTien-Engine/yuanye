import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.node_param" for NodeParam
import "blueprint.variant" for Variant, VAR_TYPE_NUMBER2
import "blueprint.blackboard" for BLACKBOARD
import "geograph.variant" for VAR_TYPE_GEO, VarGeo
import "editor.colors" for Colors
import "maths.vector" for Vector2, Vector3
import "graphics" for Painter, Graphics
import "math" for Math
import "gui" for MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE
import "geometry" for Line, Polyline

var NODE_RADIUS = 3

class Canvas is Node
{
	init()
	{
		super.init()

		this.exports = [
			Pin(this, "geo",  VAR_TYPE_GEO),
			Pin(this, "size", VAR_TYPE_NUMBER2),
		]

		this.params.add(NodeParam("type", "quad", { "combo" : [ "quad", "tri4", "tri8" ] }))
		this.params.add(NodeParam("size", Vector2(4, 4)))
		this.params.add(NodeParam("unit", 25))

		this.layout()

		this.conn_segs = []

		this.last_sel = nil
		this.curr_pos = nil
		this.draw_arc = false

		this.v_geo = nil
	}

	calc_value(idx)
	{
		if (idx == 0)
		{
			if (!this.v_geo) {
				this.v_geo = this.build_ret_geo()
			}
			return this.v_geo
		}
		else if (idx == 1)
		{
			var size = this.query_param("size").value
			var unit = this.query_param("unit").value
			return Variant(Vector2(size.x * unit, size.y * unit))
		}

		return nil
	}

	to_string(name) 
	{
		var ret = super.to_string(name)
		ret = ret + "\n%(name).conn_segs = %(this.conn_segs)\n"
		return ret
	}

	draw_editor() 
	{
		var pt = Painter.init()

		var size = this.query_param("size").value
		var unit = this.query_param("unit").value

		var type = this.query_param("type").value
		if (type == "quad") {
			this.draw_quad_canvas(pt, size, unit)
		} else if (type == "tri4") {
			this.draw_tri4_canvas(pt, size, unit)
		} else if (type == "tri8") {
			this.draw_tri8_canvas(pt, size, unit)
		}

		this.draw_edited_shapes(pt, unit)

		Graphics.draw_painter(pt)
	}

	draw_quad_canvas(pt, size, unit)
	{
		// border
		var width  = size.x * unit
		var height = size.y * unit
		pt.add_rect(nil, [0, 0, width, height], Colors.select_red(), 2)

		// points
		for (var y = 0; y <= size.y; y = y + 1) {
			for (var x = 0; x <= size.x; x = x + 1) {
				this.draw_ctrl_pos(pt, x * unit, y * unit)
			}
		}
	}

	draw_tri4_canvas(pt, size, unit)
	{
		// border
		var width  = size.x * unit
		var height = size.y * unit
		var verts = [ 0, 0, width, 0, 0, height ]
		pt.add_polygon(nil, verts, Colors.select_red(), 2)

		// points
		for (var y = 0; y <= size.y; y = y + 1) {
			for (var x = 0; x <= size.x; x = x + 1) {
				if ((size.x - x) >= y) {
					this.draw_ctrl_pos(pt, x * unit, y * unit)
				}
			}
		}
	}

	draw_tri8_canvas(pt, size, unit)
	{
		// border
		var width  = size.x * unit
		var height = size.y * unit
		var verts = [ 0, 0, width, 0, width, height ]
		pt.add_polygon(nil, verts, Colors.select_red(), 2)

		// points
		for (var y = 0; y <= size.y; y = y + 1) {
			for (var x = 0; x <= size.x; x = x + 1) {
				if (x >= y) {
					this.draw_ctrl_pos(pt, x * unit, y * unit)
				}
			}
		}
	}

	draw_ctrl_pos(pt, x, y)
	{
		pt.add_circle_filled(nil, x, y, NODE_RADIUS, [255, 0, 0, 255], 8)
	}

	draw_edited_shapes(pt, unit)
	{
		// conn_segs
		for (var i = 0; i < this.conn_segs.count; i = i + 2)
		{
			var p0 = this.conn_segs[i]
			var p1 = this.conn_segs[i + 1]
			if (p0.z == 1 and p1.z == 1)
			{
				var x0 = p0.x * unit
				var y0 = p0.y * unit
				var x1 = p1.x * unit
				var y1 = p1.y * unit

				var dx = Math.abs(x1 - x0)
				var dy = Math.abs(y1 - y0)
				var r = (dx + dy) / 2
				var cx = p0.x * unit
				var cy = p1.y * unit
				var s = Math.atan2(y0 - cy, x0 - cx)
				var e = Math.atan2(y1 - cy, x1 - cx)
				pt.add_arc(nil, cx, cy, r, s, e, [255, 255, 255], 2, 12)
			}
			else
			{
				var line = [ p0.x * unit, p0.y * unit, p1.x * unit, p1.y * unit ]
				pt.add_line(nil, line, [255, 255, 255], 2)
			}
		}

		// curr line
		if (this.last_sel and this.curr_pos) 
		{
			var line = [ this.last_sel.x * unit, this.last_sel.y * unit, this.curr_pos.x, this.curr_pos.y ]
			pt.add_line(nil, line, [255, 255, 255], 2)
		}
	}

	on_mouse_pressed(x, y, btn) 
	{
		if (btn == MOUSE_LEFT or btn == MOUSE_MIDDLE)
		{
			var pos = BLACKBOARD.editor_cam.screen2world(Vector2(x, y))
			this.last_sel = this.query_node_by_pos(pos)

			if (btn == MOUSE_MIDDLE) {
				this.draw_arc = true
			}
		}
		else if (btn == MOUSE_RIGHT)
		{
			var pos = BLACKBOARD.editor_cam.screen2world(Vector2(x, y))
			var node = this.query_node_by_pos(pos)
			this.remove_segment(node)

			this.v_geo = nil
		}
	}

	on_mouse_released(x, y, btn) 
	{
		import "blueprint.blackboard" for BLACKBOARD
		var pos = BLACKBOARD.editor_cam.screen2world(Vector2(x, y))

		var ipos = this.query_node_by_pos(pos)
		if (this.last_sel and ipos)
		{
			var s = Vector3(this.last_sel.x, this.last_sel.y, 0)
			var e = Vector3(ipos.x, ipos.y, 0)

			if (this.draw_arc) {
				s.z = 1
				e.z = 1
			}

			this.conn_segs.add(s)
			this.conn_segs.add(e)

			this.v_geo = nil
		}

		this.last_sel = nil
		this.curr_pos = nil
		this.draw_arc = false
	}

	on_mouse_dragged(x, y, btn) 
	{
		this.curr_pos = BLACKBOARD.editor_cam.screen2world(Vector2(x, y))
	}

	query_node_by_pos(pos)
	{
		var region = NODE_RADIUS * 2

		var size = this.query_param("size").value
		var unit = this.query_param("unit").value
		var width  = size.x * unit
		var height = size.y * unit
		if (pos.x < -region or pos.x > width + region or pos.y < -region or pos.y > height + region) {
			return nil
		}

		var ix = Math.round(pos.x / unit)
		var iy = Math.round(pos.y / unit)
		var dx = Math.abs(pos.x - unit * ix)
		var dy = Math.abs(pos.y - unit * iy)
		if (dx < region and dy < region) {
			return Vector2(ix, iy)
		} else {
			return nil
		}
	}

	remove_segment(node)
	{
		var find = nil

		for (var i = 0; i < this.conn_segs.count; i = i + 2)
		{
			var end = this.conn_segs[i + 1]
			if (end.x == node.x and end.y == node.y) {
				find = i
			}
		}

		if (find) 
		{
			this.conn_segs.removeAt(find)
			this.conn_segs.removeAt(find)

			this.remove_segment(node)
		}
	}

	build_ret_geo()
	{
		var unit = this.query_param("unit").value

		var geos = []
		for (var i = 0; i < this.conn_segs.count; i = i + 2)
		{
			var p0 = this.conn_segs[i]
			var p1 = this.conn_segs[i + 1]

			var shape = nil
			if (p0.z == 1 and p1.z == 1)
			{
				shape = this.build_arc_polyline(p0.x * unit, p0.y * unit, p1.x * unit, p1.y * unit)
			}
			else
			{
				shape = Line.init()
				shape.set(p0.x * unit, p0.y * unit, p1.x * unit, p1.y * unit)
			}

			var geo = VarGeo()
			geo.shape = shape
			geos.add(Variant(VAR_TYPE_GEO, geo))
		}

		return Variant(geos)
	}

	build_arc_polyline(x0, y0, x1, y1)
	{
		var dx = x1 - x0
		var dy = y1 - y0

//		var r = Math.sqrt(dx * dx + dy * dy) / 2
//		var cx = (x0 + x1) / 2
//		var cy = (y0 + y1) / 2

		var r = (Math.abs(dx) + Math.abs(dy)) / 2
		var cx = x0
		var cy = y1

		var verts = []

		var s_angle = Math.atan2(y0 - cy, x0 - cx)
		var e_angle = Math.atan2(y1 - cy, x1 - cx)
		var num = 5
		for (var i = 0; i <= num; i = i + 1)
		{
			var a = s_angle + (e_angle - s_angle) / num * i
			verts.add(cx + Math.cos(a) * r)
			verts.add(cy + Math.sin(a) * r)
		}

		var shape = Polyline.init()
		shape.set_vertices(verts)

		return shape
	}
}